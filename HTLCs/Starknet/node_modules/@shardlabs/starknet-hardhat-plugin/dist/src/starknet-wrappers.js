"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VenvWrapper = exports.DockerWrapper = exports.StarknetWrapper = void 0;
const axios_1 = __importDefault(require("axios"));
const path_1 = __importDefault(require("path"));
const starknet_1 = require("starknet");
const cairo1_compiler_1 = require("./cairo1-compiler");
const constants_1 = require("./constants");
const starknet_docker_proxy_1 = require("./starknet-docker-proxy");
const starknet_plugin_error_1 = require("./starknet-plugin-error");
const starknet_venv_proxy_1 = require("./starknet-venv-proxy");
const venv_1 = require("./utils/venv");
class StarknetWrapper {
    constructor(externalServer, hre) {
        this.externalServer = externalServer;
        this.hre = hre;
        // this is dangerous since hre get set here, before being fully initialized (e.g. active network not yet set)
        // it's dangerous because in getters (e.g. get gatewayUrl) we rely on it being initialized
    }
    get gatewayUrl() {
        const url = this.hre.starknet.networkConfig.url;
        if (this.externalServer.isDockerDesktop) {
            for (const protocol of ["http://", "https://", ""]) {
                for (const host of ["localhost", "127.0.0.1"]) {
                    if (url === `${protocol}${host}`) {
                        return `${protocol}${constants_1.DOCKER_HOST}`;
                    }
                    const prefix = `${protocol}${host}:`;
                    if (url.startsWith(prefix)) {
                        return url.replace(prefix, `${protocol}${constants_1.DOCKER_HOST}:`);
                    }
                }
            }
        }
        return url;
    }
    async execute(command, args) {
        return await this.externalServer.post({
            command,
            args
        });
    }
    prepareDeprecatedCompileOptions(options) {
        const ret = [
            options.file,
            "--abi",
            options.abi,
            "--output",
            options.output,
            "--cairo_path",
            options.cairoPath
        ];
        if (options.accountContract) {
            ret.push("--account_contract");
        }
        if (options.disableHintValidation) {
            ret.push("--disable_hint_validation");
        }
        return ret;
    }
    async deprecatedCompile(options) {
        const preparedOptions = this.prepareDeprecatedCompileOptions(options);
        const executed = await this.execute("starknet-compile-deprecated", preparedOptions);
        return executed;
    }
    async compileCairoToSierra(options) {
        const args = this.prepareCairoToSierraOptions(options);
        const command = this.getCairo1Command(options.binDirPath, constants_1.CAIRO1_COMPILE_BIN, args);
        const executed = (0, cairo1_compiler_1.exec)(command.join(" "));
        return executed;
    }
    async compileSierraToCasm(options) {
        const args = this.prepareSierraToCasmOptions(options);
        const command = this.getCairo1Command(options.binDirPath, constants_1.CAIRO1_SIERRA_COMPILE_BIN, args);
        const executed = (0, cairo1_compiler_1.exec)(command.join(" "));
        return executed;
    }
    prepareCairoToSierraOptions(options) {
        const args = [];
        if (options?.replaceIds === true) {
            args.push("-r");
        }
        if (options.allowedLibfuncsListName) {
            args.push("--allowed-libfuncs-list-name", options.allowedLibfuncsListName);
        }
        if (options.allowedLibfuncsListFile) {
            args.push("--allowed-libfuncs-list-file", options.allowedLibfuncsListFile);
        }
        if (options?.singleFile === true) {
            args.push("--single-file");
        }
        args.push(options.path);
        if (options.output) {
            args.push(options.output);
        }
        return args;
    }
    prepareSierraToCasmOptions(options) {
        const args = [];
        if (options.allowedLibfuncsListName) {
            args.push("--allowed-libfuncs-list-name", options.allowedLibfuncsListName);
        }
        if (options.allowedLibfuncsListFile) {
            args.push("--allowed-libfuncs-list-file", options.allowedLibfuncsListFile);
        }
        if (options?.addPythonicHints === true) {
            args.push("--add-pythonic-hints");
        }
        args.push(options.file);
        if (options.output) {
            args.push(options.output);
        }
        return args;
    }
    getCairo1Command(binDirPath, binCommand, args) {
        const cairo1Bin = path_1.default.join(binDirPath, binCommand);
        return [cairo1Bin, ...args];
    }
    async declare(options) {
        return this.hre.starknetJs.declare(options.contract, options.sender, options.signature, options.nonce, options.maxFee);
    }
    async getTxStatus(options) {
        return this.hre.starknetJs.getTxStatus(options.hash);
    }
    async getTransactionTrace(options) {
        return this.hre.starknetJs.getTransactionTrace(options.hash);
    }
    async getTransactionReceipt(options) {
        return this.hre.starknetJs.getTransactionReceipt(options.hash);
    }
    async getTransaction(options) {
        return await this.hre.starknetJs.getTransaction(options.hash);
    }
    async getBlock(options) {
        return this.hre.starknetJs.getBlock(options.hash ?? options.number);
    }
    async getNonce(options) {
        return this.hre.starknetJs.getNonce(options.address, options.blockHash ?? options.blockNumber);
    }
    async getClassHash(artifactPath) {
        const executed = await this.execute("get_class_hash", [artifactPath]);
        if (executed.statusCode) {
            throw new starknet_plugin_error_1.StarknetPluginError(executed.stderr.toString());
        }
        return executed.stdout.toString().trim();
    }
    async getCompiledClassHash(casmPath) {
        const executed = await this.execute("get_compiled_class_hash", [casmPath]);
        if (executed.statusCode) {
            throw new starknet_plugin_error_1.StarknetPluginError(executed.stderr.toString());
        }
        return executed.stdout.toString().trim();
    }
    async getSierraContractClassHash(casmPath) {
        const executed = await this.execute("get_contract_class_hash", [casmPath]);
        if (executed.statusCode) {
            throw new starknet_plugin_error_1.StarknetPluginError(executed.stderr.toString());
        }
        return executed.stdout.toString().trim();
    }
    async estimateMessageFee(functionName, fromAddress, toAddress, inputs) {
        const body = {
            from_address: fromAddress,
            to_address: toAddress,
            entry_point_selector: starknet_1.selector.getSelectorFromName(functionName),
            payload: inputs.map((item) => starknet_1.num.toHex(BigInt(item)))
        };
        const response = await axios_1.default.post(`${this.hre.starknet.networkConfig.url}/feeder_gateway/estimate_message_fee`, body);
        const { gas_price, gas_usage, overall_fee, unit } = response.data;
        return {
            amount: BigInt(overall_fee),
            unit,
            gas_price: BigInt(gas_price),
            gas_usage: BigInt(gas_usage)
        };
    }
}
exports.StarknetWrapper = StarknetWrapper;
function getFullImageName(image) {
    return `${image.repository}:${image.tag}`;
}
class DockerWrapper extends StarknetWrapper {
    constructor(image, rootPath, cairoPaths, hre) {
        const externalServer = new starknet_docker_proxy_1.StarknetDockerProxy(image, rootPath, cairoPaths);
        super(externalServer, hre);
        this.image = image;
        this.rootPath = rootPath;
        console.log(`${constants_1.PLUGIN_NAME} plugin using dockerized environment (${getFullImageName(image)})`);
    }
}
exports.DockerWrapper = DockerWrapper;
class VenvWrapper extends StarknetWrapper {
    constructor(venvPath, hre) {
        let pythonPath;
        if (venvPath === "active") {
            console.log(`${constants_1.PLUGIN_NAME} plugin using the active environment.`);
            pythonPath = "python3";
        }
        else {
            venvPath = (0, venv_1.normalizeVenvPath)(venvPath);
            console.log(`${constants_1.PLUGIN_NAME} plugin using environment at ${venvPath}`);
            pythonPath = (0, venv_1.getPrefixedCommand)(venvPath, "python3");
        }
        super(new starknet_venv_proxy_1.StarknetVenvProxy(pythonPath), hre);
    }
    get gatewayUrl() {
        return this.hre.starknet.networkConfig.url;
    }
}
exports.VenvWrapper = VenvWrapper;
//# sourceMappingURL=starknet-wrappers.js.map