"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomScarbWrapper = exports.DockerizedScarbWrapper = exports.ScarbWrapper = void 0;
const child_process_1 = require("child_process");
const starknet_plugin_error_1 = require("./starknet-plugin-error");
const constants_1 = require("./constants");
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
class ScarbWrapper {
    static getInstance(cliArgs, hre) {
        if (this.instance) {
            return this.instance;
        }
        else if (cliArgs.scarbCommand) {
            this.instance = new CustomScarbWrapper(cliArgs.scarbCommand);
        }
        else if (hre.config.starknet.scarbCommand) {
            this.instance = new CustomScarbWrapper(hre.config.starknet.scarbCommand);
        }
        else {
            this.instance = new DockerizedScarbWrapper(hre.config.starknet.dockerizedVersion, hre.config.paths.root);
        }
        return this.instance;
    }
}
exports.ScarbWrapper = ScarbWrapper;
class DockerizedScarbWrapper extends ScarbWrapper {
    constructor(imageTag, projectRootPath) {
        super();
        this.projectRootPath = projectRootPath;
        throw new starknet_plugin_error_1.StarknetPluginError("Dockerized Scarb is not yet supported. " +
            "If you have Scarb installed on your machine, provide its path via scarbCommand in hardhat config, " +
            "or via --scarb-command of hardhat starknet-build");
        // UNCOMMENT THIS WHEN DOCKERIZED SCARB SUPPORTED
        // const repository = CAIRO_CLI_DOCKER_REPOSITORY;
        // const tag = getCairoCliImageTagByArch(imageTag);
        // this.formattedImage = `${repository}:${tag}`;
        // console.log(`${PLUGIN_NAME} plugin using dockerized Scarb (${this.formattedImage})`);
    }
    build(packageConfigPath, artifactDirPath) {
        const packageDir = path_1.default.dirname(packageConfigPath);
        // If not specified, inside the container it tries to write cache to /.cache
        // which is not allowed for a non-root user. So here we are setting it to the path used by Scarb
        // in many non-docker environments
        const globalCacheDir = path_1.default.join(os_1.default.tmpdir(), ".cache", "scarb");
        const execution = (0, child_process_1.spawnSync)("docker", [
            "run",
            "--rm",
            ...["-v", `${packageDir}:${packageDir}`],
            ...["-v", `${this.projectRootPath}:${this.projectRootPath}`],
            ...["-v", `${globalCacheDir}:${globalCacheDir}`],
            // https://unix.stackexchange.com/questions/627027/files-created-by-docker-container-are-owned-by-root
            ...["-u", `${os_1.default.userInfo().uid}:${os_1.default.userInfo().gid}`],
            this.formattedImage,
            "scarb",
            ...["--manifest-path", packageConfigPath],
            ...["--target-dir", artifactDirPath],
            ...["--global-cache-dir", globalCacheDir],
            "build"
        ]);
        return {
            statusCode: execution.status,
            stdout: execution.stdout,
            stderr: execution.stderr
        };
    }
}
exports.DockerizedScarbWrapper = DockerizedScarbWrapper;
class CustomScarbWrapper extends ScarbWrapper {
    constructor(scarbCommand) {
        super();
        this.scarbCommand = scarbCommand;
        // validate
        const execution = (0, child_process_1.spawnSync)(scarbCommand, ["--version"]);
        // on mac, properties of spawnSync result can be null if invalid command
        if (execution.status !== 0) {
            throw new starknet_plugin_error_1.StarknetPluginError(`Not a legal executable Scarb command: ${scarbCommand}.\n${execution.stderr?.toString()}`);
        }
        // log
        const versionString = execution.stdout.toString().trim().split("\n").join(", ");
        console.log(`${constants_1.PLUGIN_NAME} plugin using custom Scarb (${versionString})`);
    }
    build(packageConfigPath, artifactDirPath) {
        const execution = (0, child_process_1.spawnSync)(this.scarbCommand, [
            ...["--manifest-path", packageConfigPath],
            ...["--target-dir", artifactDirPath],
            "build"
        ]);
        return {
            statusCode: execution.status,
            stderr: execution.stderr,
            stdout: execution.stdout
        };
    }
}
exports.CustomScarbWrapper = CustomScarbWrapper;
//# sourceMappingURL=scarb-wrapper.js.map