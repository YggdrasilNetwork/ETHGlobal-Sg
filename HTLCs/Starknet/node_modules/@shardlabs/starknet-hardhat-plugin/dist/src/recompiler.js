"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Recompiler = exports.Cache = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const crypto_1 = require("crypto");
const task_actions_1 = require("./task-actions");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
// Cache file name
const CACHE_FILE_NAME = "cairo-files-cache.json";
class Cache {
    constructor(hre) {
        this.hre = hre;
        this.cache = {};
        this.fsPromises = fs_1.default.promises;
    }
    // Returns the contract data from the cache
    async getCache() {
        await this.loadCache();
        return this.cache;
    }
    // Sets the cache
    setCache(cacheData) {
        this.cache = cacheData;
    }
    // Returns the cache file path
    getCacheFilePath() {
        return path_1.default.join(this.hre.config.paths.cache, CACHE_FILE_NAME);
    }
    // Returns the cache directory path
    getCacheDirPath() {
        return path_1.default.join(this.hre.config.paths.cache);
    }
    // Loads the cache from the file
    async loadCache() {
        const cacheDirPath = this.getCacheDirPath();
        // Creates cache directory if it doesn't exist
        if (!fs_1.default.existsSync(cacheDirPath)) {
            fs_1.default.mkdirSync(cacheDirPath, { recursive: true });
        }
        const cacheFilePath = this.getCacheFilePath();
        if (fs_1.default.existsSync(cacheFilePath)) {
            const cacheBuffer = await this.fsPromises.readFile(cacheFilePath);
            this.setCache(JSON.parse(cacheBuffer.toString() || "{}"));
        }
        else {
            await fs_1.default.promises.writeFile(cacheFilePath, JSON.stringify({}) + "\n");
            this.setCache({});
        }
    }
    // Saves the cache to the file
    async saveCache() {
        const cacheFilePath = this.getCacheFilePath();
        await this.fsPromises.writeFile(cacheFilePath, JSON.stringify(this.cache, null, " ") + "\n");
    }
}
exports.Cache = Cache;
class Recompiler {
    constructor(hre) {
        this.cache = new Cache(hre);
        this.hre = hre;
    }
    // Gets hash of each .cairo file inside source
    async getContractHash(paths) {
        const { starknetSources: defaultSourcesPath } = paths;
        const sourceRegex = new RegExp("^" + defaultSourcesPath + "/");
        const artifactsDir = (0, utils_1.getArtifactPath)(defaultSourcesPath, paths);
        const newCacheEntry = {};
        // Get sources from source path. Check only cairo file extensions
        const filesList = await (0, utils_1.traverseFiles)(defaultSourcesPath, "*.cairo");
        // Select file name
        for (const cairoContract of filesList) {
            const data = await this.cache.fsPromises.readFile(cairoContract);
            const hash = (0, crypto_1.createHash)("sha256");
            hash.update(data);
            const suffix = cairoContract.replace(sourceRegex, "");
            const fileName = path_1.default.basename(suffix, ".cairo");
            const abiPath = path_1.default.join(artifactsDir, suffix, `${fileName}${constants_1.ABI_SUFFIX}`);
            const outputPath = path_1.default.join(artifactsDir, suffix, `${fileName}.json`);
            newCacheEntry[cairoContract] = {
                contentHash: hash.digest("hex").toString(),
                outputPath,
                abiPath
            };
        }
        return newCacheEntry;
    }
    // Gets cache entry of a given cairo file plus artifacts
    async getCacheEntry(file, output, abi, cairoPath, args) {
        const data = await this.cache.fsPromises.readFile(file);
        const hash = (0, crypto_1.createHash)("sha256");
        hash.update(data);
        const newCacheEntry = {};
        newCacheEntry[file] = {
            contentHash: hash.digest("hex").toString(),
            outputPath: output,
            abiPath: abi
        };
        if (args?.disableHintValidation) {
            newCacheEntry[file].disableHintValidation = true;
        }
        if (args?.accountContract) {
            newCacheEntry[file].accountContract = true;
        }
        if (cairoPath) {
            newCacheEntry[file].cairoPath = args.cairoPath;
        }
        return newCacheEntry;
    }
    // Updates cache entry with new contracts
    getUpdatedCache(oldCache, newCacheEntry) {
        const updatedCacheEntry = oldCache;
        for (const contractName in newCacheEntry) {
            if (oldCache[contractName]?.contentHash !== newCacheEntry[contractName].contentHash) {
                updatedCacheEntry[contractName] = newCacheEntry[contractName];
            }
        }
        return updatedCacheEntry;
    }
    // Checks artifacts availability
    async checkArtifacts(paths, newCacheEntry) {
        // Set to save contracts with changed content & unavailable artifacts
        const changed = new Set();
        const { starknetSources: defaultSourcesPath } = paths;
        const artifactsDir = (0, utils_1.getArtifactPath)(defaultSourcesPath, paths);
        // Traverse on artifacts directory
        // Create if it doesn't exist
        if (!fs_1.default.existsSync(artifactsDir)) {
            fs_1.default.mkdirSync(artifactsDir, { recursive: true });
        }
        const artifactsList = await (0, utils_1.traverseFiles)(artifactsDir, "*.json");
        for (const name in newCacheEntry) {
            const outputPath = newCacheEntry[name].outputPath;
            const abiPath = newCacheEntry[name].abiPath;
            if (!artifactsList.includes(outputPath) || !artifactsList.includes(abiPath)) {
                changed.add(name);
            }
        }
        return changed;
    }
    // Compile changed contracts
    async compileChangedContracts(newCacheEntry, changed) {
        for (const changedContract of changed) {
            const entry = newCacheEntry[changedContract];
            const compileArguments = {
                paths: [changedContract],
                disableHintValidation: entry?.disableHintValidation,
                accountContract: entry?.accountContract,
                cairoPath: entry?.cairoPath
            };
            await (0, task_actions_1.starknetDeprecatedCompileAction)(compileArguments, this.hre);
        }
    }
    // Updated set with changed and new contracts
    async updateSet(cache, newCacheEntry, changed) {
        for (const contractName in newCacheEntry) {
            // Add new contracts that are not in cache before
            if (!cache[contractName]) {
                changed.add(contractName);
                continue;
            }
            // Add contracts that contain a change in content
            if (newCacheEntry[contractName].contentHash !== cache[contractName].contentHash) {
                changed.add(contractName);
            }
        }
        // Remove deleted sources from old cache by overwriting it
        this.cache.setCache(newCacheEntry);
        await this.cache.saveCache();
        return changed;
    }
    // Handles cache on Starknet cli calls
    async handleCache() {
        // If recompile is not enabled, do nothing
        if (!this.hre.userConfig?.starknet?.recompile)
            return;
        const paths = this.hre.config.paths;
        try {
            const oldCache = await this.cache.getCache();
            const newCacheEntry = await this.getContractHash(paths);
            const changedContracts = await this.checkArtifacts(paths, newCacheEntry);
            const updatedSet = await this.updateSet(oldCache, newCacheEntry, changedContracts);
            await this.compileChangedContracts(newCacheEntry, updatedSet);
        }
        catch (error) {
            // If there is an error, do not recompile
            console.error(error);
            process.exit(1);
        }
    }
    // Updates cache with new contract and artifacts
    async updateCache(args, file, output, abi, cairoPath) {
        const oldCache = await this.cache.getCache();
        const newCacheEntry = await this.getCacheEntry(file, output, abi, cairoPath, args);
        const updatedCache = this.getUpdatedCache(oldCache, newCacheEntry);
        this.cache.setCache(updatedCache);
    }
    // Calls save cache after compilation
    async saveCache() {
        await this.cache.saveCache();
    }
}
exports.Recompiler = Recompiler;
//# sourceMappingURL=recompiler.js.map