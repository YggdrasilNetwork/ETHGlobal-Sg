"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cairo1ContractClass = exports.StarknetContract = exports.StarknetContractFactory = exports.parseFeeEstimation = exports.iterativelyCheckStatus = exports.isTxAccepted = exports.extractClassHash = exports.InteractChoice = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const starknet_1 = require("starknet");
const adapt_1 = require("../adapt");
const constants_1 = require("../constants");
const starknet_plugin_error_1 = require("../starknet-plugin-error");
const utils_1 = require("../utils");
/**
 * Enumerates the ways of interacting with a contract.
 */
class InteractChoice {
    constructor(
    /**
     * The way it's supposed to be used passed to CLI commands.
     */
    cliCommand, 
    /**
     * The way it's supposed to be used internally in code.
     */
    internalCommand, 
    /**
     * Indicates whether the belonging CLI option allows specifying max_fee.
     */
    allowsMaxFee, 
    /**
     * The version of the transaction.
     */
    transactionVersion) {
        this.cliCommand = cliCommand;
        this.internalCommand = internalCommand;
        this.allowsMaxFee = allowsMaxFee;
        this.transactionVersion = transactionVersion;
    }
}
InteractChoice.INVOKE = new InteractChoice(["invoke"], "invoke", true, constants_1.TRANSACTION_VERSION);
InteractChoice.CALL = new InteractChoice(["call"], "call", false, constants_1.QUERY_VERSION);
InteractChoice.ESTIMATE_FEE = new InteractChoice(["invoke", "--estimate_fee"], "estimateFee", false, constants_1.QUERY_VERSION);
exports.InteractChoice = InteractChoice;
function extractClassHash(response) {
    return extractFromResponse(response, /^Contract class hash: (.*)$/m);
}
exports.extractClassHash = extractClassHash;
function extractTxHash(response) {
    return extractFromResponse(response, /^Transaction hash: (.*)$/m);
}
function extractFromResponse(response, regex) {
    const matched = response.match(regex);
    if (!matched || !matched[1]) {
        throw new starknet_plugin_error_1.StarknetPluginError(`Could not parse response. Check that you're using the correct network. Response received: ${response}`);
    }
    return matched[1];
}
async function checkStatus(hash, starknetWrapper) {
    const executed = await starknetWrapper.getTxStatus({
        hash
    });
    if (executed.statusCode) {
        throw new starknet_plugin_error_1.StarknetPluginError(executed.stderr.toString());
    }
    const response = executed.stdout.toString();
    try {
        const responseParsed = JSON.parse(response);
        return responseParsed;
    }
    catch (err) {
        throw new starknet_plugin_error_1.StarknetPluginError(`Cannot interpret the following: ${response}`);
    }
}
const ACCEPTABLE_STATUSES = ["PENDING", "ACCEPTED_ON_L2", "ACCEPTED_ON_L1"];
function isTxAccepted(statusObject) {
    return ACCEPTABLE_STATUSES.includes(statusObject.tx_status);
}
exports.isTxAccepted = isTxAccepted;
const UNACCEPTABLE_STATUSES = ["REJECTED", "REVERTED"];
function isTxRejected(statusObject) {
    return UNACCEPTABLE_STATUSES.includes(statusObject.tx_status);
}
async function iterativelyCheckStatus(txHash, starknetWrapper, resolve, reject, retryCount = 10) {
    // eslint-disable-next-line no-constant-condition
    while (true) {
        let count = retryCount;
        let statusObject;
        let error;
        while (count > 0) {
            // This promise is rejected usually if the network is unavailable
            statusObject = await checkStatus(txHash, starknetWrapper).catch((reason) => {
                error = reason;
                return undefined;
            });
            // Check count at 1 to avoid unnecessary waiting(sleep) in the last iteration
            if (statusObject || count === 1) {
                break;
            }
            await (0, utils_1.sleep)(constants_1.CHECK_STATUS_RECOVER_TIMEOUT);
            (0, utils_1.warn)("Retrying transaction status check...");
            count--;
        }
        if (!statusObject) {
            (0, utils_1.warn)("Checking transaction status failed.");
            return reject(error);
        }
        else if (isTxAccepted(statusObject)) {
            return resolve(statusObject.tx_status);
        }
        else if (isTxRejected(statusObject)) {
            const adaptedError = (0, utils_1.adaptLog)(JSON.stringify(statusObject, null, 4));
            return reject(new Error(adaptedError));
        }
        await (0, utils_1.sleep)(constants_1.CHECK_STATUS_TIMEOUT);
    }
}
exports.iterativelyCheckStatus = iterativelyCheckStatus;
/**
 * Reads the ABI from `abiPath`
 */
function readAbi(abiPath) {
    return starknet_1.hash.formatSpaces(node_fs_1.default.readFileSync(abiPath).toString("ascii").trim());
}
/**
 * Converts `rawAbi` to an object for lookup by name
 */
function mapAbi(rawAbi) {
    const abiArray = starknet_1.json.parse(rawAbi);
    const abi = {};
    extractAbiEntries(abiArray, abi);
    return abi;
}
/**
 * Recursively extract abi entries and populate the provided `abi` object.
 */
function extractAbiEntries(abiArray, abi) {
    for (const abiEntry of abiArray) {
        if ("items" in abiEntry) {
            extractAbiEntries(abiEntry.items, abi);
        }
        else {
            if (!abiEntry.name) {
                const msg = `Abi entry has no name: ${abiEntry}`;
                throw new starknet_plugin_error_1.StarknetPluginError(msg);
            }
            abi[abiEntry.name] = abiEntry;
        }
    }
}
/**
 * Add `signature` elements to to `starknetArgs`, if there are any.
 * @param signature array of transaction signature elements
 */
function handleSignature(signature) {
    if (signature) {
        return signature.map((s) => s.toString());
    }
    return [];
}
/**
 * Extract events from the ABI.
 * @param abi the path where ABI is stored on disk.
 * @returns an object mapping ABI entry names with their values.
 */
function extractEventSpecifications(abi) {
    const events = {};
    for (const abiEntryName in abi) {
        if (abi[abiEntryName].type === "event") {
            const event = abi[abiEntryName];
            const encodedEventName = starknet_1.selector.getSelectorFromName(event.name);
            events[encodedEventName] = event;
        }
    }
    return events;
}
function parseFeeEstimation(raw) {
    const matchedAmount = raw.match(/^The estimated fee is: (\d*) WEI \(.* ETH\)\./m);
    const matchedGasUsage = raw.match(/^Gas usage: (\d*)/m);
    const matchedGasPrice = raw.match(/^Gas price: (\d*) WEI/m);
    if (matchedAmount && matchedGasUsage && matchedGasPrice) {
        return {
            amount: BigInt(matchedAmount[1]),
            unit: "wei",
            gas_price: BigInt(matchedGasPrice[1]),
            gas_usage: BigInt(matchedGasUsage[1])
        };
    }
    throw new starknet_plugin_error_1.StarknetPluginError(`Cannot parse fee estimation response:\n${raw}`);
}
exports.parseFeeEstimation = parseFeeEstimation;
/**
 * Returns a modified copy of the provided object with its blockNumber set to pending.
 * @param options the options object with a blockNumber key
 */
function defaultToPendingBlock(options) {
    const adaptedOptions = (0, utils_1.copyWithBigint)(options);
    if (adaptedOptions.blockNumber === undefined) {
        // using || operator would not handle the zero case correctly
        adaptedOptions.blockNumber = "pending";
    }
    return adaptedOptions;
}
class StarknetContractFactory {
    constructor(config) {
        this.hre = config.hre;
        this.abiPath = config.abiPath;
        this.abiRaw = readAbi(this.abiPath);
        this.abi = mapAbi(this.abiRaw);
        this.metadataPath = config.metadataPath;
        this.casmPath = config.casmPath;
        const constructorPredicate = this.resolveConstructorPredicate();
        this.constructorAbi = (0, utils_1.findConstructor)(this.abi, constructorPredicate);
    }
    resolveConstructorPredicate() {
        if (!this.isCairo1()) {
            return (abiEntry) => {
                return abiEntry.type === "constructor";
            };
        }
        const casmJson = JSON.parse(node_fs_1.default.readFileSync(this.casmPath, "utf-8"));
        if (casmJson?.compiler_version.split(".")[0] === "0") {
            const msg = ".CASM json should have been generated with a compiler version >= 1";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        const constructors = casmJson?.entry_points_by_type?.CONSTRUCTOR;
        if (!constructors || constructors.length === 0) {
            return () => false;
        }
        // Can be removed after new cairo release.
        if (constructors.length > 1) {
            const msg = "There can be at most 1 constructor.";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        // Can be simplified once starkware fixes multiple constructor issue.
        // Precomputed selector can be used if only 'constructor' name allowed
        const constructorSelector = constructors[0].selector;
        return (abiEntry) => {
            return starknet_1.selector.getSelectorFromName(abiEntry.name) === constructorSelector;
        };
    }
    /**
     * Declare a contract class.
     * @param options optional arguments to class declaration
     * @returns transaction hash as a hex string
     */
    async declare(options = {}) {
        const executed = await this.hre.starknetWrapper.declare({
            contract: this.metadataPath,
            maxFee: (options.maxFee || 0).toString(),
            token: options.token,
            signature: handleSignature(options.signature),
            sender: options.sender,
            nonce: options.nonce?.toString()
        });
        if (executed.statusCode) {
            const msg = `Could not declare class: ${executed.stderr.toString()}`;
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        const executedOutput = executed.stdout.toString();
        const txHash = extractTxHash(executedOutput);
        return new Promise((resolve, reject) => {
            iterativelyCheckStatus(txHash, this.hre.starknetWrapper, () => resolve(txHash), (error) => {
                reject(new starknet_plugin_error_1.StarknetPluginError(`Declare transaction ${txHash}: ${error}`));
            });
        });
    }
    handleConstructorArguments(constructorArguments) {
        if (!this.constructorAbi) {
            const argsProvided = Object.keys(constructorArguments || {}).length;
            if (argsProvided) {
                const msg = `No constructor arguments required but ${argsProvided} provided`;
                throw new starknet_plugin_error_1.StarknetPluginError(msg);
            }
            return [];
        }
        return (0, adapt_1.adaptInputUtil)(this.constructorAbi.name, constructorArguments, this.constructorAbi.inputs, this.abi, this.isCairo1());
    }
    /**
     * Returns a contract instance with set address.
     * No address validity checks are performed.
     * @param address the address of a previously deployed contract
     * @returns the contract instance at the provided address
     */
    getContractAt(address) {
        if (!address) {
            throw new starknet_plugin_error_1.StarknetPluginError("No address provided");
        }
        if (typeof address !== "string" || !constants_1.HEXADECIMAL_REGEX.test(address)) {
            throw new starknet_plugin_error_1.StarknetPluginError(`Address must be 0x-prefixed hex string. Got: "${address}".`);
        }
        const contract = new StarknetContract({
            abiPath: this.abiPath,
            hre: this.hre,
            isCairo1: this.isCairo1()
        });
        contract.address = address;
        return contract;
    }
    getAbiPath() {
        return this.abiPath;
    }
    isCairo1() {
        return !!this.casmPath;
    }
    async getClassHash() {
        const method = this.isCairo1() ? "getSierraContractClassHash" : "getClassHash";
        this.classHash =
            this.classHash ?? (await this.hre.starknetWrapper[method](this.metadataPath));
        return this.classHash;
    }
}
exports.StarknetContractFactory = StarknetContractFactory;
class StarknetContract {
    constructor(config) {
        this.hre = config.hre;
        this.abiPath = config.abiPath;
        this.abiRaw = readAbi(this.abiPath);
        this.abi = mapAbi(this.abiRaw);
        this.isCairo1 = config.isCairo1;
        this.eventsSpecifications = extractEventSpecifications(this.abi);
    }
    get address() {
        return this._address;
    }
    set address(address) {
        this._address = address;
        return;
    }
    get provider() {
        return this.hre.starknetJs.provider;
    }
    /**
     * Set a custom abi and abi path to the contract
     * @param implementation the contract factory of the implementation to be set
     */
    setImplementation(implementation) {
        this.abi = implementation.abi;
        this.abiPath = implementation.abiPath;
    }
    /**
     * Invoke the function by name and optionally provide arguments in an array.
     * For a usage example @see {@link call}
     * @param functionName
     * @param args arguments to Starknet contract function
     * @options optional additions to invoking
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    async invoke(functionName, args, options = {}) {
        try {
            const adaptedInput = options.rawInput
                ? args
                : this.adaptInput(functionName, args);
            const { transaction_hash: txHash } = await this.provider.invokeFunction({
                contractAddress: this.address,
                entrypoint: functionName,
                calldata: adaptedInput,
                signature: options.signature.map(String)
            }, {
                nonce: options.nonce ?? (await this.provider.getNonceForAddress(this.address)),
                maxFee: options.maxFee,
                version: InteractChoice.INVOKE.transactionVersion
            });
            return new Promise((resolve, reject) => {
                iterativelyCheckStatus(txHash, this.hre.starknetWrapper, () => resolve(txHash), (error) => {
                    reject(new starknet_plugin_error_1.StarknetPluginError(`Invoke transaction ${txHash}: ${error}`));
                });
            });
        }
        catch (error) {
            if (!(error instanceof Error))
                throw error;
            throw new starknet_plugin_error_1.StarknetPluginError(error.message, error);
        }
    }
    /**
     * Call the function by name and optionally provide arguments in an array.
     *
     * E.g. If your contract has a function
     * ```text
     * func double_sum(x: felt, y: felt) -> (res: felt):
     *     return (res=(x + y) * 2)
     * end
     * ```
     * then you would call it like:
     * ```typescript
     * const contract = ...;
     * const { res: sum } = await contract.call("double_sum", { x: 2, y: 3 });
     * console.log(sum);
     * ```
     * which would result in:
     * ```text
     * > 10n
     * ```
     *
     * If options.rawOutput, the Promised object holds a property `response` with an array of strings.
     *
     * @param functionName
     * @param args arguments to Starknet contract function
     * @param options optional additions to calling
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    async call(functionName, args, options = {}) {
        try {
            const adaptedOptions = defaultToPendingBlock(options);
            const adaptedInput = adaptedOptions.rawInput
                ? args
                : this.adaptInput(functionName, args);
            const { result } = await this.provider.callContract({
                contractAddress: this.address,
                entrypoint: functionName,
                calldata: adaptedInput
            }, adaptedOptions.blockNumber);
            // align to legacy stdout output
            const response = result.map(adapt_1.formatFelt).join(" ");
            if (options.rawOutput) {
                return { response };
            }
            return this.adaptOutput(functionName, response);
        }
        catch (error) {
            if (!(error instanceof Error))
                throw error;
            throw new starknet_plugin_error_1.StarknetPluginError(error.message, error);
        }
    }
    /**
     * Computes L1-to-L2 message fee estimation
     * @param {string} functionName Function name for entry point selector
     * @param {StringMap} args - Arguments to Starknet contract function
     * @returns Fee estimation
     */
    async estimateMessageFee(functionName, args) {
        // Check if functionName is annotated with @l1_handler
        const func = this.abi[functionName];
        if (!func?.type || func.type.toString() !== "l1_handler") {
            throw new starknet_plugin_error_1.StarknetPluginError(`Cannot estimate message fee on "${functionName}" - not an @l1_handler`);
        }
        const adaptedInput = this.adaptInput(functionName, args);
        // Remove value of from_address from the input array
        const fromAddress = adaptedInput.shift();
        return this.hre.starknetWrapper.estimateMessageFee(functionName, fromAddress, this.address, adaptedInput);
    }
    /**
     * Estimate the gas fee of executing `functionName` with `args`.
     * @param functionName
     * @param args arguments to Starknet contract function
     * @param options optional execution specifications
     * @returns an object containing the amount and the unit of the estimation
     */
    async estimateFee(functionName, args, options = {}) {
        try {
            const { nonce, maxFee, signature } = defaultToPendingBlock(options);
            const result = await this.provider.getInvokeEstimateFee({
                contractAddress: this.address,
                calldata: args,
                signature: signature.map(String)
            }, {
                nonce: nonce ?? (await this.provider.getNonceForAddress(this.address)),
                maxFee: maxFee,
                version: InteractChoice.ESTIMATE_FEE.transactionVersion
            }, options.blockNumber);
            return {
                amount: result.overall_fee,
                unit: "wei",
                gas_price: result.gas_price,
                gas_usage: result.gas_consumed
            };
        }
        catch (error) {
            if (!(error instanceof Error))
                throw error;
            throw new starknet_plugin_error_1.StarknetPluginError(error.message, error);
        }
    }
    /**
     * Returns the ABI of the whole contract.
     * @returns contract ABI
     */
    getAbi() {
        return this.abi;
    }
    /**
     * Adapt structured `args` to unstructured array expected by e.g. Starknet CLI.
     * @param functionName the name of the function to adapt
     * @param args structured args
     * @returns unstructured args
     */
    adaptInput(functionName, args) {
        const func = this.abi[functionName];
        if (!func) {
            const msg = `Function '${functionName}' doesn't exist on ${this.abiPath}.`;
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        if (Array.isArray(args)) {
            throw new starknet_plugin_error_1.StarknetPluginError("Arguments should be passed in the form of an object.");
        }
        return (0, adapt_1.adaptInputUtil)(functionName, args, func.inputs, this.abi, this.isCairo1);
    }
    /**
     * Adapt unstructured `rawResult` to a structured object.
     * @param functionName the name of the function that produced the output
     * @param rawResult the function output as as unparsed space separated string
     * @returns structured output
     */
    adaptOutput(functionName, rawResult) {
        const func = this.abi[functionName];
        return (0, adapt_1.adaptOutputUtil)(rawResult, func.outputs, this.abi);
    }
    /**
     * Decode the events to a structured object with parameter names.
     * Only decodes the events originating from this contract.
     * @param events as received from the server.
     * @returns structured object with parameter names.
     * @throws if no events decoded
     */
    decodeEvents(events) {
        const abi = starknet_1.json.parse(this.abiRaw);
        const abiEvents = starknet_1.events.getAbiEvents(abi);
        const abiStructs = starknet_1.CallData.getAbiStruct(abi);
        const decodedEvents = starknet_1.events
            .parseEvents(events, abiEvents, abiStructs, {})
            .map((event) => {
            const [name, data] = Object.entries(event)[0];
            return { name, data };
        });
        return decodedEvents;
    }
}
exports.StarknetContract = StarknetContract;
class Cairo1ContractClass extends StarknetContract {
    constructor(config) {
        super(config);
        this.sierraProgram = config.sierraProgram;
        this.contractClassVersion = config.contractClassVersion;
        this.entryPointsByType = config.entryPointsByType;
    }
    /**
     * Returns the compiled class.
     * @returns object of a compiled contract class
     */
    getCompiledClass() {
        return {
            sierra_program: this.sierraProgram,
            contract_class_version: this.contractClassVersion,
            entry_points_by_type: this.entryPointsByType,
            abi: this.abiRaw
        };
    }
}
exports.Cairo1ContractClass = Cairo1ContractClass;
//# sourceMappingURL=index.js.map