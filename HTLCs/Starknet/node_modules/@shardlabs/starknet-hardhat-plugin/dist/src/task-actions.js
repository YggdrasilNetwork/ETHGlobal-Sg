"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.starknetPluginVersionAction = exports.starknetRunAction = exports.starknetTestAction = exports.starknetVoyagerAction = exports.amarnaAction = exports.starknetBuildAction = exports.starknetDeprecatedCompileAction = exports.starknetCompileCairo1Action = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const axios_1 = __importDefault(require("axios"));
const FormData = require("form-data");
const starknet_plugin_error_1 = require("./starknet-plugin-error");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const external_server_1 = require("./external-server");
const recompiler_1 = require("./recompiler");
const package_json_1 = require("../package.json");
const toml = __importStar(require("@iarna/toml"));
const scarb_wrapper_1 = require("./scarb-wrapper");
const cairo1_compiler_1 = require("./cairo1-compiler");
function checkSourceExists(sourcePath) {
    if (!fs.existsSync(sourcePath)) {
        const msg = `Source expected to be at ${sourcePath}, but not found.`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
}
/**
 * Transfers logs and generates a return status code.
 *
 * @param executed The process result of running the container
 * @returns 0 if succeeded, 1 otherwise
 */
function processExecuted(executed, logStatus) {
    if (executed.stdout.length) {
        console.log((0, utils_1.adaptLog)(executed.stdout.toString()));
    }
    if (executed.stderr.length) {
        // synchronize param names reported by actual CLI with param names used by this plugin
        const err = executed.stderr.toString();
        const replacedErr = (0, utils_1.adaptLog)(err);
        console.error(replacedErr);
    }
    if (logStatus) {
        const finalMsg = executed.statusCode ? "Failed" : "Succeeded âœ…";
        console.log(`\t${finalMsg}\n`);
    }
    return executed.statusCode ? 1 : 0;
}
/**
 * First deletes the file if it already exists. Then creates an empty file at the provided path.
 * Unlinking/deleting is necessary if user switched from docker to venv.
 * @param filePath the file to be recreated
 */
function initializeFile(filePath) {
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
    fs.closeSync(fs.openSync(filePath, "w"));
}
function getFileName(filePath) {
    return path.basename(filePath, path.extname(filePath));
}
class ScarbConfigValidationError extends starknet_plugin_error_1.StarknetPluginError {
    constructor(path, message, parent) {
        super(`Invalid config file ${path}: ${message}\n` +
            "To skip this validation, use the --skip-validate flag in the CLI", parent);
    }
}
function loadScarbTomlFromPath(tomlPath, validate) {
    const config = toml.parse(fs.readFileSync(tomlPath, "utf-8").toString());
    const packageName = config.package.name;
    if (validate) {
        // it's an array of possible compilation configs
        const contractTargetConfigs = config?.target["starknet-contract"] || [];
        const configCandidates = contractTargetConfigs.filter((config) => !config.name || config.name === packageName);
        if (configCandidates.length === 0) {
            throw new ScarbConfigValidationError(tomlPath, "Property 'name' of [[target.starknet-contract]] must be left out or equal the [package] name");
        }
        else if (configCandidates.length > 1) {
            // this case is handled by Scarb
        }
        const contractTargetConfig = configCandidates[0]; // assume length = 1
        if (!contractTargetConfig || !contractTargetConfig.sierra || !contractTargetConfig.casm) {
            throw new ScarbConfigValidationError(tomlPath, "To allow later loading of this project's contracts, " +
                "your TOML file must set 'sierra' and 'casm' to `true` under [[target.starknet-contract]]");
        }
    }
    return config;
}
function loadScarbMainArtifact(scarbArtifactDirPath, packageName) {
    const mainPackageArtifactPath = path.join(scarbArtifactDirPath, `${packageName}.starknet_artifacts.json`);
    if (!fs.existsSync(mainPackageArtifactPath)) {
        const msg = `Error in building ${packageName}, could not find ${mainPackageArtifactPath}`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
    return JSON.parse(fs.readFileSync(mainPackageArtifactPath, "utf-8").toString());
}
async function findPackageConfigPaths(traversablePaths, root, configFileName = "Scarb.toml") {
    // collect all package configs by traversing provided paths
    const packageConfigPaths = [];
    for (let traversablePath of traversablePaths) {
        traversablePath = (0, utils_1.adaptPath)(root, traversablePath);
        checkSourceExists(traversablePath);
        const traversionResult = await (0, utils_1.traverseFiles)(traversablePath, configFileName);
        packageConfigPaths.push(...traversionResult.filter((p) => path.basename(p) == configFileName));
    }
    if (!packageConfigPaths.length) {
        const msg = `No projects to build. Could not find directories containing ${configFileName}`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
    return packageConfigPaths;
}
async function starknetCompileCairo1Action(args, hre) {
    const binDirPath = await (0, cairo1_compiler_1.getCairoBinDirPath)(args, hre.config.starknet);
    const root = hre.config.paths.root;
    const rootRegex = new RegExp("^" + root);
    const defaultSourcesPath = hre.config.paths.starknetSources;
    const sourcesPaths = args.paths || [defaultSourcesPath];
    const artifactsPath = hre.config.paths.starknetArtifacts;
    let statusCode = 0;
    for (let sourcesPath of sourcesPaths) {
        sourcesPath = (0, utils_1.adaptPath)(root, sourcesPath);
        checkSourceExists(sourcesPath);
        const recompiler = new recompiler_1.Recompiler(hre);
        const files = await (0, utils_1.traverseFiles)(sourcesPath, "*.cairo");
        for (const file of files) {
            console.log("Compiling", file);
            const dirSuffix = file.replace(rootRegex, "");
            const fileName = getFileName(dirSuffix);
            const dirPath = path.join(artifactsPath, dirSuffix);
            const outputPath = path.join(dirPath, `${fileName}${constants_1.CAIRO1_SIERRA_SUFFIX}`);
            fs.mkdirSync(dirPath, { recursive: true });
            initializeFile(outputPath);
            // Compile to sierra representation
            {
                const executed = await hre.starknetWrapper.compileCairoToSierra({
                    path: file,
                    output: outputPath,
                    binDirPath,
                    replaceIds: args.replaceIds,
                    allowedLibfuncsListName: args.allowedLibfuncsListName,
                    allowedLibfuncsListFile: args.allowedLibfuncsListFile,
                    singleFile: args.singleFile
                });
                statusCode += processExecuted(executed, true);
                if (executed.statusCode) {
                    // continue with compiling to casm only if compiling to sierra succeeded
                    continue;
                }
            }
            // Copy abi array from output to abiOutput
            const abiOutput = path.join(dirPath, `${fileName}${constants_1.ABI_SUFFIX}`);
            initializeFile(abiOutput);
            const outputJson = JSON.parse(fs.readFileSync(outputPath, "utf-8"));
            fs.writeFileSync(abiOutput, JSON.stringify(outputJson.abi) + "\n");
            const casmOutput = path.join(dirPath, `${fileName}${constants_1.CAIRO1_ASSEMBLY_SUFFIX}`);
            initializeFile(casmOutput);
            // Compile sierra to casm representation
            {
                const executed = await hre.starknetWrapper.compileSierraToCasm({
                    file: outputPath,
                    output: casmOutput,
                    binDirPath,
                    addPythonicHints: args.addPythonicHints,
                    allowedLibfuncsListName: args.allowedLibfuncsListName,
                    allowedLibfuncsListFile: args.allowedLibfuncsListFile
                });
                statusCode += processExecuted(executed, true);
            }
            // Update cache after compilation
            await recompiler.updateCache(args, file, outputPath, abiOutput);
        }
        await recompiler.saveCache();
    }
    if (statusCode) {
        const msg = `Failed compilation of ${statusCode} contract${statusCode === 1 ? "" : "s"}.`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
}
exports.starknetCompileCairo1Action = starknetCompileCairo1Action;
async function starknetDeprecatedCompileAction(args, hre) {
    const root = hre.config.paths.root;
    const rootRegex = new RegExp("^" + root);
    const defaultSourcesPath = hre.config.paths.starknetSources;
    const sourcesPaths = args.paths || [defaultSourcesPath];
    const artifactsPath = hre.config.paths.starknetArtifacts;
    const cairoPaths = [defaultSourcesPath, root];
    if (args.cairoPath) {
        args.cairoPath.split(":").forEach((path) => {
            cairoPaths.push(path);
        });
    }
    if (hre.config.paths.cairoPaths) {
        hre.config.paths.cairoPaths.forEach((path) => {
            cairoPaths.push(path);
        });
    }
    for (let i = 0; i < cairoPaths.length; i++) {
        if (!path.isAbsolute(cairoPaths[i])) {
            cairoPaths[i] = (0, utils_1.adaptPath)(root, cairoPaths[i]);
        }
    }
    const cairoPath = cairoPaths.join(":");
    let statusCode = 0;
    for (let sourcesPath of sourcesPaths) {
        sourcesPath = (0, utils_1.adaptPath)(root, sourcesPath);
        checkSourceExists(sourcesPath);
        const files = await (0, utils_1.traverseFiles)(sourcesPath, "*.cairo");
        const recompiler = new recompiler_1.Recompiler(hre);
        for (const file of files) {
            console.log("Compiling", file);
            const dirSuffix = file.replace(rootRegex, "");
            const fileName = getFileName(dirSuffix);
            const dirPath = path.join(artifactsPath, dirSuffix);
            const outputPath = path.join(dirPath, `${fileName}.json`);
            const abiPath = path.join(dirPath, `${fileName}${constants_1.ABI_SUFFIX}`);
            fs.mkdirSync(dirPath, { recursive: true });
            initializeFile(outputPath);
            initializeFile(abiPath);
            const executed = await hre.starknetWrapper.deprecatedCompile({
                file,
                output: outputPath,
                abi: abiPath,
                cairoPath,
                accountContract: args.accountContract,
                disableHintValidation: args.disableHintValidation
            });
            // Update cache after compilation
            await recompiler.updateCache(args, file, outputPath, abiPath, cairoPath);
            statusCode += processExecuted(executed, true);
        }
        await recompiler.saveCache();
    }
    if (statusCode) {
        const msg = `Failed compilation of ${statusCode} contract${statusCode === 1 ? "" : "s"}.`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
}
exports.starknetDeprecatedCompileAction = starknetDeprecatedCompileAction;
async function starknetBuildAction(args, hre) {
    const root = hre.config.paths.root;
    const rootRegex = new RegExp("^" + root);
    const defaultSourcesPath = hre.config.paths.starknetSources;
    const traversablePaths = args.paths || [defaultSourcesPath];
    const packageConfigPaths = await findPackageConfigPaths(traversablePaths, root);
    const artifactsPath = hre.config.paths.starknetArtifacts;
    const scarbWrapper = scarb_wrapper_1.ScarbWrapper.getInstance(args, hre);
    let statusCode = 0;
    for await (const packageConfigPath of packageConfigPaths) {
        // each config path is assumed to be of format $hardhat_project_root/<CAIRO_DIR>/Scarb.toml
        let packageConfig = null;
        try {
            packageConfig = loadScarbTomlFromPath(packageConfigPath, !args.skipValidate);
        }
        catch (error) {
            console.error(error);
            statusCode += 1;
            continue;
        }
        const packageName = packageConfig.package.name;
        // strip "Scarb.toml" from path end to get $hardhat_project_root/<CAIRO_DIR>/
        const packageDir = path.dirname(packageConfigPath);
        console.log(`Building package ${packageName} from ${packageDir}`);
        // not using path.basename(...) because it could be a more complex path than just the directory name
        const dirSuffix = packageDir.replace(rootRegex, ""); // <CAIRO_DIR>/
        const artifactDirPath = path.join(artifactsPath, dirSuffix); // starknet-artifacts/<CAIRO_DIR>/
        const executed = scarbWrapper.build(packageConfigPath, artifactDirPath);
        statusCode += processExecuted(executed, true);
        if (executed.statusCode) {
            // continue with compiling to casm only if compiling to sierra succeeded
            continue;
        }
        // by default (dev mode, unlike the release mode), scarb stores artifacts in subdir "dev"
        const scarbArtifactDirPath = path.join(artifactDirPath, "dev");
        // load scarb's main build artifact
        const mainPackageArtifact = loadScarbMainArtifact(scarbArtifactDirPath, packageName);
        for (const contractEntry of mainPackageArtifact.contracts) {
            // package_contract (underscore separation)
            const fileName = `${contractEntry.package_name}_${contractEntry.contract_name}`;
            // artifact dir created by us, not the one created by scarb
            const ourArtifactDirPath = path.join(artifactDirPath, `${fileName}.cairo`);
            fs.mkdirSync(ourArtifactDirPath, { recursive: true });
            // We want to create artifacts compatible with our contract loading mechanisms.
            // To achieve this, we will now copy scarb artifacts
            // this is false if user skipped validation
            if (contractEntry.artifacts.sierra) {
                const scarbSierraPath = path.join(scarbArtifactDirPath, contractEntry.artifacts.sierra);
                const ourSierraPath = path.join(ourArtifactDirPath, `${fileName}${constants_1.CAIRO1_SIERRA_SUFFIX}`);
                fs.copyFileSync(scarbSierraPath, ourSierraPath);
                // Copy abi array from output to abiOutput
                const abiOutput = path.join(ourArtifactDirPath, `${fileName}${constants_1.ABI_SUFFIX}`);
                initializeFile(abiOutput);
                const outputJson = JSON.parse(fs.readFileSync(scarbSierraPath, "utf-8"));
                fs.writeFileSync(abiOutput, JSON.stringify(outputJson.abi) + "\n");
            }
            // this is false if user skipped validation
            if (contractEntry.artifacts.casm) {
                const scarbCasmPath = path.join(scarbArtifactDirPath, contractEntry.artifacts.casm);
                const ourCasmPath = path.join(ourArtifactDirPath, `${fileName}${constants_1.CAIRO1_ASSEMBLY_SUFFIX}`);
                fs.copyFileSync(scarbCasmPath, ourCasmPath);
            }
        }
    }
    if (statusCode) {
        const msg = `Failed building of ${statusCode} project${statusCode === 1 ? "" : "s"}.`;
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
}
exports.starknetBuildAction = starknetBuildAction;
async function amarnaAction(args, hre) {
    await hre.amarnaDocker.run(args);
}
exports.amarnaAction = amarnaAction;
/**
 * Extracts the verification URL assigned to the network provided.
 * If no `networkName` is provided, defaults to Alpha testnet.
 * If `networkName` is provided, but not supported for verification, an error is thrown.
 * @param networkName the name of the network
 * @param hre the runtime environment from which network data is extracted
 * @param origin short string describing where/how `networkName` was specified
 */
function getVerificationNetwork(networkName, hre, origin) {
    networkName || (networkName = constants_1.ALPHA_TESTNET);
    const network = (0, utils_1.getNetwork)(networkName, hre.config.networks, origin);
    if (!network.verificationUrl) {
        throw new starknet_plugin_error_1.StarknetPluginError(`Network ${networkName} does not support Voyager verification.`);
    }
    return network;
}
async function starknetVoyagerAction(args, hre) {
    const network = getVerificationNetwork(args.starknetNetwork, hre, "--starknet-network");
    const voyagerUrl = `${network.verificationUrl}${args.address}/code`;
    const verifiedUrl = `${network.verifiedUrl}${args.address}#code`;
    let isVerified = false;
    try {
        const resp = await axios_1.default.get(voyagerUrl);
        const data = resp.data;
        if (data.contract) {
            if (data.contract.length > 0 || Object.keys(data.contract).length > 0) {
                isVerified = true;
            }
        }
    }
    catch (error) {
        const msg = "Something went wrong while checking if the contract has already been verified.";
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
    if (isVerified) {
        console.log(`Contract at address ${args.address} has already been verified`);
        console.log(`Check it out on Voyager: ${verifiedUrl}`);
    }
    else {
        await handleContractVerification(args, voyagerUrl, verifiedUrl, hre);
    }
}
exports.starknetVoyagerAction = starknetVoyagerAction;
function getMainVerificationPath(contractPath, root) {
    if (!path.isAbsolute(contractPath)) {
        contractPath = (0, utils_1.adaptPath)(root, contractPath);
        if (!fs.existsSync(contractPath)) {
            throw new starknet_plugin_error_1.StarknetPluginError(`File ${contractPath} does not exist`);
        }
    }
    return contractPath;
}
async function handleContractVerification(args, voyagerUrl, verifiedUrl, hre) {
    // Set main contract path
    const mainPath = getMainVerificationPath(args.path, hre.config.paths.root);
    const paths = [mainPath];
    const bodyFormData = new FormData();
    bodyFormData.append("compiler-version", args.compilerVersion);
    const accountContract = args.accountContract ? "true" : "false";
    bodyFormData.append("account-contract", accountContract);
    bodyFormData.append("license", args.license || "No License (None)");
    // Dependencies (non-main contracts) are in args.paths
    if (args.paths) {
        paths.push(...args.paths);
    }
    const sourceRegex = new RegExp("^" + hre.config.paths.starknetSources + "/");
    const contractNameDefault = mainPath.replace(sourceRegex, "");
    // If contract name is not provided, use the default
    bodyFormData.append("contract-name", contractNameDefault);
    // Appends all contracts to the form data with the name "file" + index
    handleMultiPartContractVerification(bodyFormData, paths, hre.config.paths.root, sourceRegex);
    await axios_1.default
        .post(voyagerUrl, bodyFormData.getBuffer(), {
        headers: bodyFormData.getHeaders()
    })
        .catch((err) => {
        throw new starknet_plugin_error_1.StarknetPluginError(`\
Could not verify the contract at address ${args.address}.
${err.response.data.message ||
            `It is hard to tell exactly what happened, but possible reasons include:
- Deployment transaction hasn't been accepted or indexed yet (check its tx_status or try in a minute)
- Wrong contract address
- Wrong files provided
- Wrong main contract chosen (first after --path)
- Voyager is down`}
            `);
    });
    console.log(`Contract has been successfully verified at address ${args.address}`);
    console.log(`Check it out on Voyager: ${verifiedUrl}`);
}
function handleMultiPartContractVerification(bodyFormData, paths, root, sourceRegex) {
    paths.forEach(function (item, index) {
        if (!path.isAbsolute(item)) {
            paths[index] = (0, utils_1.adaptPath)(root, item);
            if (!fs.existsSync(paths[index])) {
                throw new starknet_plugin_error_1.StarknetPluginError(`File ${paths[index]} does not exist`);
            }
        }
        bodyFormData.append("file" + index, fs.readFileSync(paths[index]), {
            filepath: paths[index].replace(sourceRegex, ""),
            contentType: "application/octet-stream"
        });
    });
}
/**
 * Used later on for network interaction.
 * @param args Hardhat CLI args
 * @param hre HardhatRuntimeEnvironment
 */
function setRuntimeNetwork(args, hre) {
    let networkName;
    let networkConfig;
    if (args.starknetNetwork) {
        networkName = args.starknetNetwork;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "--starknet-network");
    }
    else if (hre.config.starknet.network) {
        networkName = hre.config.starknet.network;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "starknet.network in hardhat.config");
    }
    else {
        networkName = constants_1.DEFAULT_STARKNET_NETWORK;
        networkConfig = (0, utils_1.getNetwork)(networkName, hre.config.networks, "default settings");
    }
    hre.starknet.network = networkName;
    hre.starknet.networkConfig = networkConfig;
    hre.starknetJs.setProvider(hre.starknet.networkConfig);
    console.log(`Using network ${hre.starknet.network} at ${hre.starknet.networkConfig.url}`);
}
async function runWithDevnet(hre, fn) {
    if (!(0, utils_1.isStarknetDevnet)(hre.starknet.network)) {
        await fn();
        return;
    }
    const devnet = (0, external_server_1.createIntegratedDevnet)(hre);
    await devnet.start();
    await fn();
    devnet.stop();
}
async function starknetTestAction(args, hre, runSuper) {
    setRuntimeNetwork(args, hre);
    await new recompiler_1.Recompiler(hre).handleCache();
    await runWithDevnet(hre, async () => {
        await runSuper(args);
    });
}
exports.starknetTestAction = starknetTestAction;
async function starknetRunAction(args, hre, runSuper) {
    if (args.starknetNetwork) {
        throw new starknet_plugin_error_1.StarknetPluginError(`Using "--starknet-network" with "hardhat run" currently does not have effect.
Use the "network" property of the "starknet" object in your hardhat config file.`);
    }
    setRuntimeNetwork(args, hre);
    await new recompiler_1.Recompiler(hre).handleCache();
    await runWithDevnet(hre, async () => {
        await runSuper(args);
    });
}
exports.starknetRunAction = starknetRunAction;
async function starknetPluginVersionAction() {
    console.log(`Version: ${package_json_1.version}`);
}
exports.starknetPluginVersionAction = starknetPluginVersionAction;
//# sourceMappingURL=task-actions.js.map