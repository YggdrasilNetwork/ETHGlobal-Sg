"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCairoBinDirPath = exports.exec = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const shelljs_1 = __importDefault(require("shelljs"));
const path_1 = __importDefault(require("path"));
const axios_1 = __importStar(require("axios"));
const starknet_plugin_error_1 = require("./starknet-plugin-error");
const constants_1 = require("./constants");
const config_json_1 = __importDefault(require("../config.json"));
const tar_fs_1 = __importDefault(require("tar-fs"));
const zlib_1 = __importDefault(require("zlib"));
const exec = (args) => {
    const result = shelljs_1.default.exec(args, {
        silent: true
    });
    return {
        statusCode: result.code,
        stdout: Buffer.from(result.stdout),
        stderr: Buffer.from(result.stderr)
    };
};
exports.exec = exec;
function getCompilerAsset() {
    const platform = os_1.default.platform();
    const arch = os_1.default.arch();
    if (platform === "linux" && arch === "x64") {
        return {
            name: "release-x86_64-unknown-linux-musl.tar.gz",
            isGzipped: true
        };
    }
    else if (platform === "darwin" && arch === "arm64") {
        return {
            name: "release-aarch64-apple-darwin.tar",
            isGzipped: false
        };
    }
    throw new Error(`Unsupported combination of platform (${platform}) and architecture (${arch}). Consider using a custom compiler (cairo1BinDir in config).`);
}
async function getCairoBinDirPath(cliArgs, starknetConfig) {
    if (starknetConfig?.cairo1BinDir && starknetConfig?.compilerVersion) {
        const msg = "Error in config file. Only one of (starknet.cairo1BinDir, starknet.compilerVersion) can be specified.";
        throw new starknet_plugin_error_1.StarknetPluginError(msg);
    }
    // give precedence to CLI specification
    const customCairo1BinDir = cliArgs?.cairo1BinDir || starknetConfig?.cairo1BinDir;
    if (customCairo1BinDir) {
        assertValidCompilerBinary(customCairo1BinDir, "starknet-compile");
        assertValidCompilerBinary(customCairo1BinDir, "starknet-sierra-compile");
        console.log(`Using cairo compiler at ${customCairo1BinDir}`);
        return customCairo1BinDir;
    }
    // default to downloaded binary
    const compilerVersion = starknetConfig?.compilerVersion || config_json_1.default.CAIRO_COMPILER;
    const downloadDistDir = getDownloadDistDir(compilerVersion);
    console.log(`Using downloaded cairo compiler ${compilerVersion}`);
    // download if not present
    const downloadBinDir = path_1.default.join(downloadDistDir, "cairo", "bin");
    if (!(isValidCompilerBinary(path_1.default.join(downloadBinDir, "starknet-compile")) &&
        isValidCompilerBinary(path_1.default.join(downloadBinDir, "starknet-sierra-compile")))) {
        await downloadAsset(compilerVersion, downloadDistDir);
    }
    return downloadBinDir;
}
exports.getCairoBinDirPath = getCairoBinDirPath;
function assertValidCompilerBinary(binDirPath, command) {
    const compilerBinaryPath = path_1.default.join(binDirPath, command);
    if (!fs_1.default.existsSync(compilerBinaryPath)) {
        throw new starknet_plugin_error_1.StarknetPluginError(`${compilerBinaryPath} not found`);
    }
    if (!isValidCompilerBinary(compilerBinaryPath)) {
        throw new starknet_plugin_error_1.StarknetPluginError(`${compilerBinaryPath} is not a valid compiler binary`);
    }
}
function isValidCompilerBinary(binaryPath) {
    return (0, exports.exec)([binaryPath, "--version"].join(" ")).statusCode === 0;
}
async function downloadAsset(version, distDir) {
    const compilerAsset = getCompilerAsset();
    const assetUrl = `${constants_1.CAIRO_COMPILER_BINARY_URL}/v${version}/${compilerAsset.name}`;
    const resp = await axios_1.default
        .get(assetUrl, {
        responseType: "stream",
        onDownloadProgress: (progressEvent) => {
            // periodically inform the user of download progress (printed on a single line)
            const percentage = Math.round((progressEvent.loaded / progressEvent.total) * 100);
            process.stdout.write(`Downloading cairo compiler: ${version} ... ${percentage}%\r`);
        }
    })
        .catch((error) => {
        const parent = error instanceof axios_1.AxiosError && error;
        if (parent.response?.status === 404) {
            throw new Error(`\nCould not download cairo ${version}. Make sure that it exists.`);
        }
        throw new Error(`\nError downloading cairo ${version} from ${assetUrl}: ${parent}`);
    });
    console.log(`Downloaded cairo compiler ${version}`);
    let pipeline = resp.data;
    if (compilerAsset.isGzipped) {
        pipeline = pipeline.pipe(zlib_1.default.createGunzip());
    }
    const extract = tar_fs_1.default.extract(distDir);
    pipeline.pipe(extract);
    return new Promise((resolve, _reject) => {
        extract.on("finish", resolve);
    });
}
function getDownloadDistDir(version) {
    const compilerDownloadPath = path_1.default.join(os_1.default.homedir(), constants_1.HIDDEN_PLUGIN_DIR, constants_1.HIDDEN_PLUGIN_COMPILER_SUBDIR, version);
    return compilerDownloadPath;
}
//# sourceMappingURL=cairo1-compiler.js.map