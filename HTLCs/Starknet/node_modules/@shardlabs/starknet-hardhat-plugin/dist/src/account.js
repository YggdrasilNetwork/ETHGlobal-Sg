"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgentAccount = exports.OpenZeppelinAccount = exports.Account = void 0;
const starknet_1 = require("starknet");
const account_utils_1 = require("./account-utils");
const constants_1 = require("./constants");
const extend_utils_1 = require("./extend-utils");
const starknet_plugin_error_1 = require("./starknet-plugin-error");
const types_1 = require("./types");
const utils_1 = require("./utils");
/**
 * Representation of an Account.
 * Multiple implementations can exist, each will be defined by an extension of this Abstract class
 */
class Account {
    constructor(starknetContract, privateKey, salt, deployed) {
        this.starknetContract = starknetContract;
        this.privateKey = privateKey;
        this.salt = salt;
        this.deployed = deployed;
        this.publicKey = starknet_1.ec.starkCurve.getStarkKey(privateKey);
    }
    /**
     * Uses the account contract as a proxy to invoke a function on the target contract with a signature
     *
     * @param toContract target contract to be called
     * @param functionName function in the contract to be called
     * @param calldata calldata to use as input for the contract call
     */
    async invoke(toContract, functionName, calldata, options) {
        if (options?.maxFee && options?.overhead) {
            const msg = "maxFee and overhead cannot be specified together";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        if (options?.maxFee === undefined || options?.maxFee === null) {
            const maxFee = await this.estimateFee(toContract, functionName, calldata, options);
            options = {
                ...options,
                maxFee: (0, utils_1.estimatedFeeToMaxFee)(maxFee.amount, options?.overhead)
            };
        }
        return (await this.interact(types_1.InteractChoice.INVOKE, toContract, functionName, calldata, options)).toString();
    }
    get address() {
        return this.starknetContract.address;
    }
    /**
     * Deploy another contract using this account
     * @param contractFactory the factory of the contract to be deployed
     * @param constructorArguments
     * @param options extra options
     * @returns the deployed StarknetContract
     */
    async deploy(contractFactory, constructorArguments, options = {}) {
        const classHash = await contractFactory.getClassHash();
        const udc = await utils_1.UDC.getInstance();
        const adaptedArgs = contractFactory.handleConstructorArguments(constructorArguments);
        const deployTxHash = await this.invoke(udc, constants_1.UDC_DEPLOY_FUNCTION_NAME, {
            classHash,
            salt: options?.salt ?? (0, utils_1.generateRandomSalt)(),
            unique: BigInt(options?.unique ?? true),
            calldata: adaptedArgs
        }, {
            maxFee: options?.maxFee,
            nonce: options?.nonce
        });
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const deploymentReceipt = await (0, extend_utils_1.getTransactionReceiptUtil)(deployTxHash, hre);
        const decodedEvents = udc.decodeEvents(deploymentReceipt.events);
        // the only event should be ContractDeployed
        const deployedContractAddress = (0, utils_1.numericToHexString)(decodedEvents[0].data.address);
        const deployedContract = contractFactory.getContractAt(deployedContractAddress);
        deployedContract.deployTxHash = deployTxHash;
        return deployedContract;
    }
    assertNotDeployed() {
        if (this.deployed) {
            const msg = "The account is not expected to be deployed.";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
    }
    assertDeployed() {
        if (!this.deployed) {
            const msg = "Prior to usage, the account must be funded and deployed.";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
    }
    async estimateFee(toContract, functionName, calldata, options) {
        return await this.interact(types_1.InteractChoice.ESTIMATE_FEE, toContract, functionName, calldata, options);
    }
    async estimateDeclareV2Fee(contractFactory, options = {}) {
        const maxFee = (options.maxFee || 0).toString();
        const version = starknet_1.hash.feeTransactionVersion_2;
        const nonce = options.nonce == null ? await this.getNonce() : options.nonce;
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const chainId = hre.starknet.networkConfig.starknetChainId;
        const compiledClassHash = await hre.starknetWrapper.getCompiledClassHash(contractFactory.casmPath);
        const classHash = await hre.starknetWrapper.getSierraContractClassHash(contractFactory.metadataPath);
        const messageHash = starknet_1.hash.calculateDeclareTransactionHash(classHash, this.address, version, maxFee, chainId, nonce, compiledClassHash);
        const signatures = this.getSignatures(messageHash);
        const data = {
            type: "DECLARE",
            sender_address: this.address,
            compiled_class_hash: compiledClassHash,
            contract_class: (0, utils_1.readCairo1Contract)(contractFactory.metadataPath).getCompiledClass(),
            signature: (0, utils_1.bnToDecimalStringArray)(signatures || []),
            version: (0, utils_1.numericToHexString)(version),
            nonce: (0, utils_1.numericToHexString)(nonce)
        };
        return await (0, account_utils_1.sendEstimateFeeTx)(data);
    }
    async estimateDeclareFee(contractFactory, options = {}) {
        if (contractFactory.isCairo1()) {
            return await this.estimateDeclareV2Fee(contractFactory, options);
        }
        const nonce = options.nonce == null ? await this.getNonce() : options.nonce;
        const maxFee = (options.maxFee || 0).toString();
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const classHash = await hre.starknetWrapper.getClassHash(contractFactory.metadataPath);
        const chainId = hre.starknet.networkConfig.starknetChainId;
        const calldata = [classHash];
        const calldataHash = starknet_1.hash.computeHashOnElements(calldata);
        const messageHash = starknet_1.hash.computeHashOnElements([
            constants_1.TransactionHashPrefix.DECLARE,
            (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            this.address,
            0,
            calldataHash,
            maxFee,
            chainId,
            (0, utils_1.numericToHexString)(nonce)
        ]);
        const signature = this.getSignatures(messageHash);
        const data = {
            type: "DECLARE",
            sender_address: this.address,
            contract_class: (0, utils_1.readContract)(contractFactory.metadataPath),
            signature: (0, utils_1.bnToDecimalStringArray)(signature || []),
            version: (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            nonce: (0, utils_1.numericToHexString)(nonce)
        };
        return await (0, account_utils_1.sendEstimateFeeTx)(data);
    }
    async estimateDeployFee(contractFactory, constructorArguments, options = {}) {
        const classHash = await contractFactory.getClassHash();
        const udc = await utils_1.UDC.getInstance();
        const adaptedArgs = contractFactory.handleConstructorArguments(constructorArguments);
        const calldata = {
            classHash,
            salt: options?.salt ?? (0, utils_1.generateRandomSalt)(),
            unique: BigInt(options?.unique ?? true),
            calldata: adaptedArgs
        };
        return await this.estimateFee(udc, constants_1.UDC_DEPLOY_FUNCTION_NAME, calldata, options);
    }
    async interact(choice, toContract, functionName, calldata, options) {
        const call = {
            functionName: functionName,
            toContract: toContract,
            calldata: calldata
        };
        return await this.multiInteract(choice, [call], options);
    }
    /**
     * Performs multiple invokes as a single transaction through this account
     * @param callParameters an array with the parameters for each invoke
     * @returns the transaction hash of the invoke
     */
    async multiInvoke(callParameters, options) {
        // Invoke only returns one transaction hash, as the multiple invokes are done by the account contract, but only one is sent to it.
        return await this.multiInteract(types_1.InteractChoice.INVOKE, callParameters, options);
    }
    /**
     * Estimate the fee of the multicall.
     * @param callParameters an array with the parameters for each call
     * @returns the total estimated fee
     */
    async multiEstimateFee(callParameters, options) {
        return await this.multiInteract(types_1.InteractChoice.ESTIMATE_FEE, callParameters, options);
    }
    async multiInteract(choice, callParameters, options = {}) {
        this.assertDeployed();
        options = (0, utils_1.copyWithBigint)(options);
        options.maxFee = BigInt(options?.maxFee || "0");
        const nonce = options.nonce == null ? await this.getNonce() : options.nonce;
        delete options.nonce; // the options object is incompatible if passed on with nonce
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const { messageHash, args } = this.handleMultiInteract(this.address, callParameters, nonce, options.maxFee, choice.transactionVersion, hre.starknet.networkConfig.starknetChainId, options.rawInput);
        if (options.signature) {
            const msg = "Custom signature cannot be specified when using Account (it is calculated automatically)";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        const contractInteractOptions = {
            signature: this.getSignatures(messageHash),
            ...options,
            rawInput: false // rawInput shouldn't affect validating args of __execute__
        };
        const contractInteractor = (this.starknetContract[choice.internalCommand]).bind(this.starknetContract);
        const executionFunctionName = this.getExecutionFunctionName();
        return contractInteractor(executionFunctionName, args, contractInteractOptions);
    }
    /**
     * Prepares the calldata and hashes the message for the multicall execution
     *
     * @param accountAddress address of the account contract
     * @param callParameters array with the call parameters
     * @param nonce current nonce
     * @param maxFee the maximum fee amount set for the contract interaction
     * @param version the transaction version
     * @param chainId the ID of the chain
     * @param rawInput if `true`, interprets calldata as already adapted into an array
     * @returns the message hash for the multicall and the arguments to execute it with
     */
    handleMultiInteract(accountAddress, callParameters, nonce, maxFee, version, chainId, rawInput) {
        const callArray = callParameters.map((callParameters) => {
            const calldata = rawInput
                ? callParameters.calldata
                : callParameters.toContract.adaptInput(callParameters.functionName, callParameters.calldata);
            return {
                contractAddress: callParameters.toContract.address,
                entrypoint: callParameters.functionName,
                calldata
            };
        });
        const executeCallArray = [];
        const rawCalldata = [];
        // Parse the Call array to create the objects which will be accepted by the contract
        callArray.forEach((call) => {
            const calldata = call.calldata;
            executeCallArray.push({
                to: BigInt(call.contractAddress),
                selector: starknet_1.selector.starknetKeccak(call.entrypoint),
                data_offset: rawCalldata.length,
                data_len: calldata.length
            });
            rawCalldata.push(...calldata);
        });
        const adaptedNonce = nonce.toString();
        const adaptedMaxFee = (0, utils_1.numericToHexString)(maxFee);
        const adaptedVersion = (0, utils_1.numericToHexString)(version);
        const messageHash = this.getMessageHash(constants_1.TransactionHashPrefix.INVOKE, accountAddress, callArray, adaptedNonce, adaptedMaxFee, adaptedVersion, chainId);
        const args = {
            call_array: executeCallArray,
            calldata: rawCalldata
        };
        return { messageHash, args };
    }
    getExecutionFunctionName() {
        return "__execute__";
    }
    async getNonce() {
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        return await hre.starknet.getNonce(this.address);
    }
    /**
     * Declare the contract class corresponding to the `contractFactory`
     * @param contractFactory
     * @param options
     * @returns transaction hash
     */
    async declare(contractFactory, options = {}) {
        if (contractFactory.isCairo1()) {
            return await this.declareV2(contractFactory, options);
        }
        let maxFee = options?.maxFee;
        if (maxFee && options?.overhead) {
            const msg = "maxFee and overhead cannot be specified together";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        const nonce = options.nonce == null ? await this.getNonce() : options.nonce;
        if (maxFee === undefined || maxFee === null) {
            const estimatedDeclareFee = await this.estimateDeclareFee(contractFactory, options);
            maxFee = (0, utils_1.estimatedFeeToMaxFee)(estimatedDeclareFee.amount, options?.overhead);
        }
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const classHash = await hre.starknetWrapper.getClassHash(contractFactory.metadataPath);
        const chainId = hre.starknet.networkConfig.starknetChainId;
        const calldata = [classHash];
        const calldataHash = starknet_1.hash.computeHashOnElements(calldata);
        const messageHash = starknet_1.hash.computeHashOnElements([
            constants_1.TransactionHashPrefix.DECLARE,
            constants_1.TRANSACTION_VERSION.toString(),
            this.address,
            0,
            calldataHash,
            maxFee.toString(),
            chainId,
            nonce.toString()
        ]);
        const signature = this.getSignatures(messageHash);
        return contractFactory.declare({
            nonce,
            signature,
            token: options.token,
            sender: this.address,
            maxFee: BigInt(maxFee)
        });
    }
    async declareV2(contractFactory, options = {}) {
        let maxFee = options?.maxFee;
        if (maxFee && options?.overhead) {
            const msg = "maxFee and overhead cannot be specified together";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        const nonce = options.nonce == null ? await this.getNonce() : options.nonce;
        if (maxFee === undefined || maxFee === null) {
            const estimatedDeclareFee = await this.estimateDeclareV2Fee(contractFactory, options);
            maxFee = (0, utils_1.estimatedFeeToMaxFee)(estimatedDeclareFee.amount, options?.overhead);
        }
        const version = starknet_1.hash.transactionVersion_2;
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const chainId = hre.starknet.networkConfig.starknetChainId;
        const compiledClassHash = await hre.starknetWrapper.getCompiledClassHash(contractFactory.casmPath);
        const classHash = await hre.starknetWrapper.getSierraContractClassHash(contractFactory.metadataPath);
        const messageHash = starknet_1.hash.calculateDeclareTransactionHash(classHash, this.address, version, maxFee, chainId, nonce, compiledClassHash);
        const signatures = this.getSignatures(messageHash);
        return (0, account_utils_1.sendDeclareV2Tx)((0, utils_1.bnToDecimalStringArray)(signatures), compiledClassHash, maxFee, this.address, version, nonce, (0, utils_1.readCairo1Contract)(contractFactory.metadataPath));
    }
}
exports.Account = Account;
/**
 * Wrapper for the OpenZeppelin implementation of an Account
 */
class OpenZeppelinAccount extends Account {
    constructor(starknetContract, privateKey, salt, deployed) {
        super(starknetContract, privateKey, salt, deployed);
    }
    static async getContractFactory() {
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        if (!this.contractFactory) {
            const contractPath = (0, account_utils_1.handleInternalContractArtifacts)("OpenZeppelinAccount", "Account", "0.5.1", hre);
            this.contractFactory = await hre.starknet.getContractFactory(contractPath);
        }
        return this.contractFactory;
    }
    /**
     * Generates a new key pair if none specified.
     * The created account needs to be deployed using the `deployAccount` method.
     * @param options
     * @returns an undeployed instance of account
     */
    static async createAccount(options = {}) {
        const signer = (0, account_utils_1.generateKeys)(options.privateKey);
        const salt = options.salt || (0, utils_1.generateRandomSalt)();
        const contractFactory = await this.getContractFactory();
        const address = starknet_1.hash.calculateContractAddressFromHash(salt, await contractFactory.getClassHash(), [signer.publicKey], "0x0" // deployer address
        );
        const contract = contractFactory.getContractAt(address);
        return new this(contract, signer.privateKey, salt, false);
    }
    getMessageHash(transactionHashPrefix, accountAddress, callArray, nonce, maxFee, version, chainId) {
        const hashable = [callArray.length];
        const rawCalldata = [];
        callArray.forEach((call) => {
            const calldata = call.calldata;
            hashable.push(call.contractAddress, starknet_1.hash.starknetKeccak(call.entrypoint), rawCalldata.length, calldata.length);
            rawCalldata.push(...calldata);
        });
        hashable.push(rawCalldata.length, ...rawCalldata);
        const calldataHash = starknet_1.hash.computeHashOnElements(hashable);
        return starknet_1.hash.computeHashOnElements([
            transactionHashPrefix,
            version,
            accountAddress,
            0,
            calldataHash,
            maxFee,
            chainId,
            nonce
        ]);
    }
    getSignatures(messageHash) {
        return (0, account_utils_1.signMultiCall)(messageHash, this.privateKey);
    }
    async estimateDeployAccountFee() {
        this.assertNotDeployed();
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const contractFactory = await OpenZeppelinAccount.getContractFactory();
        const classHash = await contractFactory.getClassHash();
        const constructorCalldata = [BigInt(this.publicKey).toString()];
        const maxFee = (0, utils_1.numericToHexString)(0);
        const nonce = (0, utils_1.numericToHexString)(0);
        const calldataHash = starknet_1.hash.computeHashOnElements([
            classHash,
            this.salt,
            ...constructorCalldata
        ]);
        const msgHash = starknet_1.hash.computeHashOnElements([
            constants_1.TransactionHashPrefix.DEPLOY_ACCOUNT,
            (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            this.address,
            0,
            calldataHash,
            maxFee,
            hre.starknet.networkConfig.starknetChainId,
            nonce
        ]);
        const signature = this.getSignatures(msgHash);
        const data = {
            type: "DEPLOY_ACCOUNT",
            class_hash: classHash,
            constructor_calldata: constructorCalldata,
            contract_address_salt: this.salt,
            signature: (0, utils_1.bnToDecimalStringArray)(signature || []),
            version: (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            nonce
        };
        return await (0, account_utils_1.sendEstimateFeeTx)(data);
    }
    async deployAccount(options = {}) {
        this.assertNotDeployed();
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        let maxFee = options?.maxFee;
        if (maxFee && options?.overhead) {
            const msg = "maxFee and overhead cannot be specified together";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        if (maxFee === undefined || maxFee === null) {
            const estimatedDeployFee = await this.estimateDeployAccountFee();
            maxFee = (0, utils_1.estimatedFeeToMaxFee)(estimatedDeployFee.amount, options?.overhead);
        }
        const contractFactory = await OpenZeppelinAccount.getContractFactory();
        const classHash = await contractFactory.getClassHash();
        const constructorCalldata = [BigInt(this.publicKey).toString()];
        const msgHash = (0, account_utils_1.calculateDeployAccountHash)(this.address, constructorCalldata, this.salt, classHash, (0, utils_1.numericToHexString)(maxFee), hre.starknet.networkConfig.starknetChainId);
        const deploymentTxHash = await (0, account_utils_1.sendDeployAccountTx)(this.getSignatures(msgHash).map((val) => val.toString()), classHash, constructorCalldata, this.salt, (0, utils_1.numericToHexString)(maxFee));
        this.starknetContract.deployTxHash = deploymentTxHash;
        this.deployed = true;
        return deploymentTxHash;
    }
    static async getAccountFromAddress(address, privateKey) {
        const contractFactory = await this.getContractFactory();
        const contract = contractFactory.getContractAt(address);
        const { publicKey: expectedPubKey } = await contract.call("getPublicKey");
        const publicKey = starknet_1.ec.starkCurve.getStarkKey(privateKey);
        if (BigInt(publicKey) !== expectedPubKey) {
            throw new starknet_plugin_error_1.StarknetPluginError("The provided private key is not compatible with the public key stored in the contract.");
        }
        return new this(contract, privateKey, undefined, true);
    }
}
exports.OpenZeppelinAccount = OpenZeppelinAccount;
/**
 * Wrapper for the Argent implementation of Account
 */
class ArgentAccount extends Account {
    constructor(starknetContract, privateKey, guardianPrivateKey, salt, deployed) {
        super(starknetContract, privateKey, salt, deployed);
        this.guardianPrivateKey = guardianPrivateKey;
        if (this.guardianPrivateKey) {
            const guardianSigner = (0, account_utils_1.generateKeys)(this.guardianPrivateKey);
            this.guardianPublicKey = guardianSigner.publicKey;
        }
    }
    static async getImplementationContractFactory() {
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        if (!this.implementationContractFactory) {
            const contractPath = (0, account_utils_1.handleInternalContractArtifacts)("ArgentAccount", "ArgentAccount", this.VERSION, hre);
            this.implementationContractFactory = await hre.starknet.getContractFactory(contractPath);
        }
        return this.implementationContractFactory;
    }
    static async getProxyContractFactory() {
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        if (!this.proxyContractFactory) {
            const contractPath = (0, account_utils_1.handleInternalContractArtifacts)("ArgentAccount", "Proxy", this.VERSION, hre);
            this.proxyContractFactory = await hre.starknet.getContractFactory(contractPath);
        }
        return this.proxyContractFactory;
    }
    static generateGuardianPublicKey(guardianPrivateKey) {
        if (!guardianPrivateKey) {
            return "0x0";
        }
        return (0, account_utils_1.generateKeys)(guardianPrivateKey).publicKey;
    }
    /**
     * Generates a new key pair if none specified.
     * Does NOT generate a new guardian key pair if none specified.
     * If you don't specify a guardian private key, no guardian will be assigned.
     * The created account needs to be deployed using the `deployAccount` method.
     * @param options
     * @returns an undeployed instance of account
     */
    static async createAccount(options = {}) {
        const signer = (0, account_utils_1.generateKeys)(options.privateKey);
        const guardianPrivateKey = options?.guardianPrivateKey;
        const guardianPublicKey = this.generateGuardianPublicKey(guardianPrivateKey);
        const salt = options.salt || (0, utils_1.generateRandomSalt)();
        const constructorCalldata = [
            this.IMPLEMENTATION_CLASS_HASH,
            starknet_1.selector.getSelectorFromName("initialize"),
            "2",
            signer.publicKey,
            guardianPublicKey
        ];
        const address = starknet_1.hash.calculateContractAddressFromHash(salt, this.PROXY_CLASS_HASH, constructorCalldata, "0x0" // deployer address
        );
        const proxyContractFactory = await this.getProxyContractFactory();
        const contract = proxyContractFactory.getContractAt(address);
        return new this(contract, signer.privateKey, guardianPrivateKey, salt, false);
    }
    getMessageHash(transactionHashPrefix, accountAddress, callArray, nonce, maxFee, version, chainId) {
        const hashable = [callArray.length];
        const rawCalldata = [];
        callArray.forEach((call) => {
            const calldata = call.calldata;
            hashable.push(call.contractAddress, starknet_1.selector.starknetKeccak(call.entrypoint), rawCalldata.length, calldata.length);
            rawCalldata.push(...calldata);
        });
        hashable.push(rawCalldata.length, ...rawCalldata);
        const calldataHash = starknet_1.hash.computeHashOnElements(hashable);
        return starknet_1.hash.computeHashOnElements([
            transactionHashPrefix,
            version,
            accountAddress,
            0,
            calldataHash,
            maxFee,
            chainId,
            nonce
        ]);
    }
    getSignatures(messageHash) {
        const signatures = (0, account_utils_1.signMultiCall)(messageHash, this.privateKey);
        if (this.guardianPrivateKey) {
            const guardianSignatures = (0, account_utils_1.signMultiCall)(messageHash, this.guardianPrivateKey);
            signatures.push(...guardianSignatures);
        }
        return signatures;
    }
    async estimateDeployAccountFee() {
        this.assertNotDeployed();
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        const nonce = (0, utils_1.numericToHexString)(0);
        const maxFee = (0, utils_1.numericToHexString)(0);
        const constructorCalldata = [
            ArgentAccount.IMPLEMENTATION_CLASS_HASH,
            starknet_1.selector.getSelectorFromName("initialize"),
            "2",
            this.publicKey,
            ArgentAccount.generateGuardianPublicKey(this.guardianPrivateKey)
        ].map((val) => BigInt(val).toString());
        const calldataHash = starknet_1.hash.computeHashOnElements([
            ArgentAccount.PROXY_CLASS_HASH,
            this.salt,
            ...constructorCalldata
        ]);
        const msgHash = starknet_1.hash.computeHashOnElements([
            constants_1.TransactionHashPrefix.DEPLOY_ACCOUNT,
            (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            this.address,
            0,
            calldataHash,
            maxFee,
            hre.starknet.networkConfig.starknetChainId,
            nonce
        ]);
        const signature = this.getSignatures(msgHash);
        const data = {
            type: "DEPLOY_ACCOUNT",
            class_hash: ArgentAccount.PROXY_CLASS_HASH,
            constructor_calldata: constructorCalldata,
            contract_address_salt: this.salt,
            signature: (0, utils_1.bnToDecimalStringArray)(signature || []),
            version: (0, utils_1.numericToHexString)(constants_1.QUERY_VERSION),
            nonce
        };
        return await (0, account_utils_1.sendEstimateFeeTx)(data);
    }
    /**
     * Deploys (initializes) the account.
     * @param options
     * @returns the tx hash of the deployment
     */
    async deployAccount(options = {}) {
        this.assertNotDeployed();
        const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
        let maxFee = options?.maxFee;
        if (maxFee && options?.overhead) {
            const msg = "maxFee and overhead cannot be specified together";
            throw new starknet_plugin_error_1.StarknetPluginError(msg);
        }
        if (maxFee === undefined || maxFee === null) {
            const estimatedDeployFee = await this.estimateDeployAccountFee();
            maxFee = (0, utils_1.estimatedFeeToMaxFee)(estimatedDeployFee.amount, options?.overhead);
        }
        const constructorCalldata = [
            ArgentAccount.IMPLEMENTATION_CLASS_HASH,
            starknet_1.selector.getSelectorFromName("initialize"),
            "2",
            this.publicKey,
            ArgentAccount.generateGuardianPublicKey(this.guardianPrivateKey)
        ].map((val) => BigInt(val).toString());
        const msgHash = (0, account_utils_1.calculateDeployAccountHash)(this.address, constructorCalldata, this.salt, ArgentAccount.PROXY_CLASS_HASH, (0, utils_1.numericToHexString)(maxFee), hre.starknet.networkConfig.starknetChainId);
        const deploymentTxHash = await (0, account_utils_1.sendDeployAccountTx)(this.getSignatures(msgHash).map((val) => val.toString()), ArgentAccount.PROXY_CLASS_HASH, constructorCalldata, this.salt, (0, utils_1.numericToHexString)(maxFee));
        const implementationFactory = await ArgentAccount.getImplementationContractFactory();
        this.starknetContract.setImplementation(implementationFactory);
        this.starknetContract.deployTxHash = deploymentTxHash;
        this.deployed = true;
        return deploymentTxHash;
    }
    /**
     * Updates the guardian key in the contract. Set it to `undefined` to remove the guardian.
     * @param newGuardianPrivateKey private key of the guardian to update
     * @returns hash of the transaction which changes the guardian
     */
    async setGuardian(newGuardianPrivateKey, invokeOptions) {
        let guardianPublicKey;
        if (!BigInt(newGuardianPrivateKey || 0)) {
            newGuardianPrivateKey = undefined;
            guardianPublicKey = undefined;
        }
        else {
            guardianPublicKey = starknet_1.ec.starkCurve.getStarkKey(newGuardianPrivateKey);
        }
        const call = {
            functionName: "changeGuardian",
            toContract: this.starknetContract,
            calldata: { newGuardian: BigInt(guardianPublicKey || 0) }
        };
        const txHash = await this.multiInvoke([call], invokeOptions);
        // set after signing
        this.guardianPrivateKey = newGuardianPrivateKey;
        this.guardianPublicKey = guardianPublicKey;
        return txHash;
    }
    /**
     * Returns an account previously deployed to `address`.
     * A check is performed if the public key stored in the account matches the provided `privateKey`.
     * No check is done for the optional guardian private key.
     * @param address
     * @param privateKey
     * @param options
     * @returns the retrieved account
     */
    static async getAccountFromAddress(address, privateKey, options = {}) {
        const contractFactory = await this.getProxyContractFactory();
        const contract = contractFactory.getContractAt(address);
        const implementationFactory = await this.getImplementationContractFactory();
        contract.setImplementation(implementationFactory);
        const { signer: expectedPubKey } = await contract.call("getSigner");
        const publicKey = starknet_1.ec.starkCurve.getStarkKey(privateKey);
        if (expectedPubKey === BigInt(0)) {
            // not yet initialized
        }
        else if (BigInt(publicKey) !== expectedPubKey) {
            throw new starknet_plugin_error_1.StarknetPluginError("The provided private key is not compatible with the public key stored in the contract.");
        }
        return new this(contract, privateKey, options.guardianPrivateKey, undefined, true);
    }
}
ArgentAccount.VERSION = "780760e4156afe592bb1feff7e769cf279ae9831";
ArgentAccount.PROXY_CLASS_HASH = "0x25ec026985a3bf9d0cc1fe17326b245dfdc3ff89b8fde106542a3ea56c5a918";
ArgentAccount.IMPLEMENTATION_CLASS_HASH = "0x33434ad846cdd5f23eb73ff09fe6fddd568284a0fb7d1be20ee482f044dabe2";
exports.ArgentAccount = ArgentAccount;
//# sourceMappingURL=account.js.map